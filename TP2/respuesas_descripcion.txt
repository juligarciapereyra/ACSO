Julieta Guillermina Garcia Pereyra

jgarciapereyra@udesa.edu.ar


Fase 1 -----------------------------------------------------------------------------------------------------------

El fragmento de código ensamblador analizado corresponde a una función denominada phase_1. La función comienza reservando espacio en la pila para datos locales, asignando 8 bytes de memoria. Posteriormente, utiliza la instrucción lea (Load Effective Address) para calcular la dirección efectiva de una cadena de caracteres almacenada en la memoria y la carga en el registro rsi. Luego, se realiza una llamada a la función strings_not_equal, que compara la cadena cargada en rsi con otra cadena. El resultado de esta comparación se almacena en el registro eax, y luego se verifica mediante la instrucción test eax, eax, que realiza una operación AND bit a bit entre el registro eax y él mismo. Si las cadenas son iguales (es decir, si eax es cero), la función restaura el puntero de pila y retorna. En caso contrario, se llama a la función explode_bomb, que maneja la situación en la que la "bomba" explota. Después de llamar a explode_bomb, hay un salto incondicional de vuelta a la dirección 401f2f, lo que puede ser parte del mecanismo de recuperación después de la explosión de la "bomba".

Para resolver la función phase_1, se utilizaron varios comandos. Primero, se estableció un punto de interrupción en la función explode_bomb mediante el comando b explode_bomb, lo que permitió detener la ejecución del programa justo antes de que ocurriera una "explosión", ofreciendo la oportunidad de examinar el estado del programa en ese punto crítico. Posteriormente, se colocó otro punto de interrupción en la función phase_1 utilizando el comando b phase_1. Esto posibilitó analizar el comportamiento de esta función específica. Una vez establecidos los puntos de interrupción, se utilizó el comando 'ni' para ejecutar el programa paso a paso, permitiendo observar la ejecución de cada instrucción y sus efectos en el estado del programa. Después, para visualizar el contenido de la cadena de caracteres pasada como argumento a la función strings_not_equal, se empleó el comando display (char*) $rsi.La instrucción display en GDB, se emplea para imprimir el valor de una expresión en cada punto de parada durante la depuración de un programa. Esta característica resulta útil al examinar el comportamiento dinámico de variables o expresiones durante la ejecución del código, permitiendo un seguimiento detallado de su evolución a lo largo del flujo de ejecución del programa. Aquí, rsi contiene la dirección de memoria de la cadena de caracteres. Para interpretar correctamente esta dirección de memoria como una cadena de caracteres, se utilizó el casting (char*). Esto ayudó a entender qué valores estaban siendo comparados dentro de la función strings_not_equal, para poder obtener la contrasena correcta: Por la libertad, asi como por la honra, se puede y se debe aventurar la vida.  


Fase 2 ------------------------------------------------------------------------------------------------------------

La fase 2 opera de la siguiente manera: inicialmente, recibe la entrada del usuario y la almacena en el registro RBX. Luego, se invoca una función en la dirección 0x4011d0, que toma como parámetros RBX y ESI, donde ESI = 0x20. Esta función tiene como objetivo encontrar el primer carácter, definido por el segundo parámetro, que aparece en la entrada. Posteriormente, se llama dos veces a la función strtol, que se utiliza para convertir una cadena que representa un número en una representación de tipo entero largo. Cada llamada captura un término de la contraseña. A continuación, el resultado de una operación aritmética, representada por a = [RBX+RAX*1-0x20], se almacena en el registro EDI. Este resultado se pasa como parámetro a la función misterio, junto con el primer y segundo término de la contraseña.

La función misterio lleva a cabo un desplazamiento aritmético hacia la derecha (shift right arithmetic) sobre la variable 'a', utilizando el valor de CL como la cantidad de bits a desplazar. Este resultado se guarda en el registro EAX, lo que permite, luego, contar la cantidad de unos presentes en su representación binaria. Este proceso se realiza dentro de un bucle que itera 32 veces para verificar los 32 bits del número. Si esta condición no se cumple, la bomba explota. Luego se verifica que el número tenga 11 unos para evitar la explosión. Después, se realiza un XOR entre el primer y el segundo término de la contraseña para verificar que tengan signo distinto, es decir, que el resultado del XOR sea negativo (1), evitando así la explosión de la bomba; de lo contrario, explota.

Para resolver esta fase, se identificó que el valor 0x20 en ASCII corresponde a un espacio en blanco, lo que sugiere que la primera función llamada en el código busca el primer espacio en blanco en la contraseña. Se dedujo que la contraseña debería estar compuesta por dos términos. Además, al comprender que la función misterio verifica que 'a' tenga 11 unos, y 'a' está conformada por los dos términos de la contraseña, se eligió que el segundo término fuera 32. Esto permite que, al reemplazar RAX con 32, el -32 se anule, dejando simplemente el valor de RBX, cumpliendo así la condición de los 11 unos. Por lo tanto, se seleccionó el número decimal 4292870144, que en binario tiene los 11 unos al principio y 21 ceros al final, formando un número de 32 bits. Como resultado, el bucle se cumple al recorrer los 32 bits del número y verificar que tenga 11 unos. Además, como 4292870144 comienza con 1 y el número decimal 32 en bits comienza con 0, se cumple la condición del XOR, lo que evita la llamada a la función que explota la bomba.

Fase 3 ------------------------------------------------------------------------------------------------------------

La función cuenta se inicia con la instrucción push para guardar los registros r13, r12, rbp y rbx en la pila, seguido de la reserva de espacio en la pila con sub rsp, 0x18. Luego, se mueve el contenido del registro rdi a rbx y se guarda el puntero al segmento de control (FS) en rax, almacenándolo en la pila. Posteriormente, se inicializa el registro rax con cero y se llama a la función malloc para asignar memoria dinámica para un búfer de tamaño 0x1e bytes, moviendo el puntero devuelto por malloc a r13. A continuación, se llama a la función sscanf, que recibe como parámetro un puntero char a la cadena de entrada y otro puntero char al formato. Si sscanf lee exactamente dos valores, el programa continúa su flujo; de lo contrario, se llama a explode_bomb. Luego, se llama a readlines, que se encarga de leer las líneas del archivo palabras.txt, guardando la dirección en el registro rsi. Luego se mueve la dirección donde está contenida la contraseña al registro rdi. Estos registros actúan como parámetros para la función cuenta.

La función cuenta realiza una búsqueda binaria recursiva entre las palabras de palabras.txt, calculando la cantidad de iteraciones que tarda en llegar a esa palabra. Una vez que se sale de cuenta, el número obtenido debe ser mayor a 0x270f para que la bomba no explote. Además, la contraseña debe cumplir la condición de que el segundo término con el cual está compuesta debe ser igual al resultado de la función cuenta para que la bomba no explote.

Para resolver esta fase, se imprimió como (char*) el registro rsi, lo que dio como resultado "$s" y "$d". Esto, junto con la clave, se pasó como parámetros a scanf, lo que sugiere que scanf esperaba leer en la contraseña una cadena y un número. Luego, se comparó el resultado de scanf con 2 para verificar que se hubieran recibido dos elementos, confirmando así la deducción anterior. Luego, se ingresó a cuenta y se realizó la búsqueda binaria, anotando todas las palabras encontradas junto con su número. Se eligió la primera palabra cuyo número cumpliera la condición de ser mayor a 9999, que fue 'desmadrar'. Para cumplir con la segunda condición, el segundo término de la contraseña debía ser el número devuelto por la función cuenta cuando se le ingresaba la palabra 'desmadrar', por lo que la contraseña se formó como 'desmadrar 12129'.

Fase 4 ------------------------------------------------------------------------------------------------------------

La cuarta fase del desafío consiste en procesar una cadena de largo 'l, la cual se almacena en el registro RBX. Posteriormente, se invoca a la función string_length para determinar la longitud real del string y se compara con 6 para evitar la detonación de la bomba. Luego, se almacena la dirección del inicio de la cadena en RAX y el final de la cadena en RDI. Un arreglo de números se inicializa y su dirección en memoria se guarda en RSI. A continuación, se entra en un ciclo que itera 6 veces. Dentro de este ciclo, se toma cada letra de la entrada del usuario, se busca su valor en la tabla ASCII y se calcula su módulo 16, el cual se utiliza como índice para acceder al valor en el arreglo. El resultado de esta operación se almacena en ECX. Una vez completado el ciclo, se compara el valor de ECX con 58. Si son iguales, se llama a la función que desactiva la bomba; de lo contrario, la bomba explota.

La resolución de esta fase se logró de la siguiente manera: primero, se utilizó una cadena con una longitud de 6 caracteres, de modo que al almacenarse en el registro RBX cumpliera con la condición inicial de que la longitud debía ser 6 para evitar que la bomba explotara. Posteriormente, se identificó el arreglo de números almacenado en la memoria: [2, 13, 7, 14, 5, 10, 6, 15, 1, 12, 3, 4, 11, 8, 10, 9]. Para que el valor en ECX fuera igual a 58, era necesario que los caracteres de la cadena ingresada coincidieran 5 veces con el número 10 y una vez con el número 8. De esta forma, el código que resuelve exitosamente esta fase es "uuuuum".


Fase Secreta ------------------------------------------------------------------------------------------------------

Para encontrar la fase secreta, se analizó la función phases_defused, que se ejecuta después de desactivar cada fase de la bomba de manera exitosa. La función comienza restando 280 bytes (0x118 en hexadecimal) del puntero de pila. Luego, obtiene el valor del registro de segmento fs y lo almacena en el marco de pila en la dirección rsp+0x108. La función compara el valor de una variable global ubicada en la dirección de memoria rip+0x11137b con 4. La comparación se realiza para verificar si el número de cadenas de entrada es igual a 4. Si lo es, la función continúa; de lo contrario, la bomba explota. Luego, llama a la función sscanf para leer tres valores de cadena de entrada. Requiere leer un %s, %d y %s. Verifica si sscanf devolvió 3, lo que significa que se leyó correctamente. Luego, compara las cadenas leídas con alguna cadena específica. Si no coinciden, imprime un mensaje de error y vuelve a la comparación de la cantidad de cadenas de entrada. Si las cadenas coinciden, imprime dos mensajes de éxito utilizando la función puts. Llama a la función secret_phase. Luego, la función retorna con un valor de 0, lo que indica que la fase ha sido superada.

Al analizar esta función, se observó que cuando se llama a la función scanf, lee la contraseña de la fase 3, por lo tanto, se debía agregar un string más a la contraseña de esta fase. Sabiendo que agregarle un término más a esta contraseña no iba a hacer que la bomba explote en la fase 3, porque el scanf de la fase 3 solo lee una string y un número. Luego, al imprimir lo que la función strings_not_equal necesitaba para devolver true, se identificó que la siguiente cadena debía ser: abrete_sesamo. Por lo tanto, se dedujo que la contraseña de la fase 3 que abre la fase secreta se veía de la siguiente forma: desmadrar 12129 abrete_sesamo.

La fase secreta realiza lo siguiente: comienza llamando a read_line para leer una línea de entrada del usuario y almacena el resultado en rax. Luego, llama a __strtol para convertir la cadena leída a un número entero long. Los parámetros pasados a __strtol son la cadena leída (rdi), la base (edx), y un puntero para almacenar la posición final de lectura (null en este caso). El número entero convertido se almacena en ebx. A continuación, resta 1 al número (sub eax,0x1) y compara si es mayor que 1000 (cmp eax,0x3e8). Si es menor o igual a 1000, continúa; de lo contrario, llama a explode_bomb. Si el número es menor o igual a 1000, el valor se mueve a esi y se llama a fun7, pasando el valor esi y un puntero a la cadena "n1".

La función fun7 es una función recursiva que realiza una búsqueda en un árbol. Comienza verificando si el primer argumento rdi es nulo. Si es así, salta a la dirección de retorno con ret. Luego, sube espacio en la pila. Mueve el valor almacenado en la dirección apuntada por rdi a edx. Compara este valor (edx) con el valor dado en el segundo argumento (esi). Dependiendo del resultado de esta comparación, la función toma diferentes caminos. Si el valor actual es mayor que el valor dado, la función se llama recursivamente con el siguiente elemento (mov rdi,QWORD PTR [rdi+0x8]) y luego se duplica el valor de retorno (add eax,eax) antes de regresar a la dirección de retorno. Si el valor actual es igual o menor que el valor dado, la función se llama recursivamente con el siguiente elemento (mov rdi,QWORD PTR [rdi+0x10]). Luego, se duplica el valor de retorno y se incrementa en 1 (lea eax,[rax+rax*1+0x1]) antes de regresar a la dirección de retorno. Si la entrada es nula, la función devuelve -1 antes de retornar.

Para resolver este problema, sabiendo que el número debe ser menor que 1000 para que la bomba no explote, se dedujo que la contraseña debe ser un número en el rango de 0 a 1001. Luego, se concluyó que el resultado de fun7 debe ser 1 para evitar llamar a explode_bomb. Por lo tanto, se necesitaba que el número llevase por la rama cuyo resultado final se calculaba como [rax+rax*1+0x1], para que rax sea igual a 0 y así obtener el resultado deseado. Por lo tanto, partiendo del número 50, el valor inicial del nodo del árbol es 36, lo que llevaría por la rama de los menores o iguales, estableciendo previamente eax en 0 y obteniendo así el resultado necesario.

